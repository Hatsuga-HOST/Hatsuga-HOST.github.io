<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Luau / Lua Obfuscator â€” Ultimate v3 (UI+UX+Animation+Logic)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;500;700;800&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#071024; --card:#0f1724; --muted:#93a0b8; --fg:#e6eef8;
  --accent1:#6d28d9; --accent2:#4f46e5; --ok:#16a34a; --danger:#ef4444;
  --glass: rgba(255,255,255,0.03);
  --glass-2: rgba(255,255,255,0.02);
  --radius:14px;
  --glass-border: rgba(120,140,255,0.12);
}
*{box-sizing:border-box}
html,body{height:100%; margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; background: radial-gradient(1200px 600px at 10% 10%, rgba(79,70,229,0.08), transparent), linear-gradient(180deg, rgba(7,16,36,1), rgba(3,8,18,1)); color:var(--fg);}
.container{max-width:1100px; margin:28px auto; padding:20px;}
.header{display:flex; gap:16px; align-items:center; justify-content:space-between; margin-bottom:12px}
.brand{display:flex; gap:12px; align-items:center}
.logo{
  width:56px; height:56px; border-radius:12px;
  background: linear-gradient(135deg,var(--accent1),var(--accent2));
  display:grid; place-items:center; font-weight:800; color:white; box-shadow:0 8px 30px rgba(79,70,229,0.18);
}
.title{font-size:20px; font-weight:700}
.subtitle{font-size:13px; color:var(--muted)}
.grid{display:grid; gap:16px; grid-template-columns: 1fr 420px;}
.card{
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  border-radius:var(--radius); padding:16px; border:1px solid var(--glass-border);
  box-shadow: 0 6px 24px rgba(3,6,20,0.6);
}
.large{min-height:480px; display:flex; flex-direction:column}
.textarea{
  width:100%; height:300px; resize:vertical; background:linear-gradient(180deg,#081226,#06101d);
  border-radius:10px; border:1px solid rgba(255,255,255,0.03); color:var(--fg); padding:12px;
  font-family:ui-monospace,SFMono-Regular,Menlo,monospace; font-size:13px; line-height:1.45;
  box-shadow: inset 0 2px 8px rgba(0,0,0,0.6);
}
.controls{display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:12px}
.btn{padding:10px 14px; border-radius:10px; border:none; cursor:pointer; font-weight:700; letter-spacing:0.2px; background:rgba(255,255,255,0.03); color:var(--fg)}
.btn.tiny{padding:8px 10px; font-weight:600}
.btn.primary{background:linear-gradient(90deg,var(--accent1),var(--accent2)); box-shadow:0 8px 20px rgba(79,70,229,0.12); color:white}
.btn.ghost{background:transparent; border:1px solid rgba(255,255,255,0.04)}
.row{display:flex; gap:10px; align-items:center}
.select, input[type="text"], input[type="file"], select{appearance:none; background:transparent; color:var(--fg); border-radius:10px; padding:8px 10px; border:1px solid rgba(255,255,255,0.03)}
.label{font-size:13px; color:var(--muted)}
.sidebar{display:flex; flex-direction:column; gap:12px}
.progress{height:12px; background:rgba(255,255,255,0.03); border-radius:10px; overflow:hidden}
.progress > i{display:block; height:100%; width:0%; background:linear-gradient(90deg,var(--accent2),#8b5cf6); transition:width .45s ease}
.features{display:grid; grid-template-columns:repeat(1,1fr); gap:8px; font-size:13px; color:var(--muted)}
.feature{display:flex; align-items:center; gap:8px; padding:8px; border-radius:8px}
.feature.ok{background:linear-gradient(90deg, rgba(34,197,94,0.06), transparent); color:var(--ok)}
.feature.no{background:linear-gradient(90deg, rgba(239,68,68,0.04), transparent); color:var(--danger)}
.footer{font-size:12px; color:var(--muted); margin-top:10px}
.small{font-size:13px; color:var(--muted)}
.preview{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.0)); border-radius:8px; padding:8px; font-family:ui-monospace,monospace; font-size:12px; color:var(--muted); max-height:120px; overflow:auto}
.hint{font-size:12px; color:var(--muted); margin-top:6px}
.switch{display:flex; gap:8px; background:var(--glass-2); padding:6px; border-radius:12px; align-items:center}
.badge{padding:6px 8px; border-radius:999px; font-weight:700; font-size:12px; background:rgba(255,255,255,0.03); color:var(--muted)}
.kv{display:flex; gap:6px; align-items:center}
.toggle{appearance:none; width:42px; height:22px; background:rgba(0,0,0,0.14); border-radius:999px; position:relative; cursor:pointer; outline:none; border:1px solid rgba(255,255,255,0.03)}
.toggle:checked{background:linear-gradient(90deg,var(--accent1),var(--accent2))}
.toggle::after{content:""; position:absolute; width:18px; height:18px; border-radius:50%; top:1px; left:2px; background:white; transition:all .18s}
.toggle:checked::after{left:22px; transform:scale(.98)}
.actionRow{display:flex; gap:8px; margin-top:10px; flex-wrap:wrap}
@media(max-width:980px){
  .grid{grid-template-columns:1fr}
  .sidebar{order:2}
  .large{order:1}
}
.anim-fade{opacity:0; transform:translateY(6px); transition:all .5s ease}
.anim-fade.visible{opacity:1; transform:translateY(0)}
.small-ghost{background:transparent; color:var(--muted); border:1px dashed rgba(255,255,255,0.03); padding:8px; border-radius:9px}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div class="brand">
      <div class="logo">LðŸ”’</div>
      <div>
        <div class="title">Luau / Lua Obfuscator â€” Ultimate v3</div>
        <div class="subtitle">Modern UI â€¢ Target: Luau & Lua 5.1 â€¢ Safe pipeline â€¢ Runtime decoder</div>
      </div>
    </div>

    <div style="display:flex; gap:10px; align-items:center">
      <div class="small">Made for: <span class="badge">Roblox (Luau) & Lua 5.1</span></div>
      <button class="btn ghost" id="sampleBtn">Insert Sample</button>
      <button class="btn tiny" id="helpBtn">Help</button>
    </div>
  </div>

  <div class="grid">
    <!-- LEFT: main -->
    <div class="card large anim-fade" id="mainCard">
      <div style="display:flex; gap:12px; align-items:flex-start; justify-content:space-between">
        <div>
          <div class="label">1) Source (paste or upload)</div>
          <div class="small hint">Supports standard Lua and Luau. Keep long bracket strings intact.</div>
        </div>
        <div style="display:flex; gap:8px; align-items:center">
          <input type="file" id="fileInput" accept=".lua,.txt" style="display:none"/>
          <button class="btn" id="uploadBtn">Upload</button>
          <button class="btn" id="clearIn">Clear</button>
        </div>
      </div>

      <textarea id="inputArea" class="textarea" placeholder="-- Paste your Luau / Lua 5.1 code here"></textarea>

      <div class="controls">
        <div class="row">
          <div class="label">Target:</div>
          <select id="targetSelect" class="select" title="Choose runtime target">
            <option value="luau">Luau (Roblox)</option>
            <option value="lua51">Lua 5.1</option>
          </select>
        </div>

        <div class="row">
          <div class="label">Level</div>
          <select id="levelSelect" class="select">
            <!-- populated by JS -->
          </select>
        </div>

        <div class="row">
          <div class="label">Key (optional)</div>
          <input id="keyInput" type="text" placeholder="Optional symmetry key / salt (affects naming & string xor)"/>
        </div>

        <div class="row switch">
          <div class="label">Anti-Tamper</div>
          <input type="checkbox" id="antiTamper" class="toggle"/>
          <div class="label">Multilayer Wrap</div>
          <input type="checkbox" id="multiWrap" class="toggle" checked/>
        </div>

        <div style="flex:1"></div>

        <div style="display:flex; gap:8px; align-items:center">
          <button class="btn primary" id="runBtn">Obfuscate</button>
          <button class="btn" id="previewBtn">Preview (small)</button>
        </div>
      </div>

      <div style="margin-top:12px">
        <div class="label">Progress</div>
        <div class="progress"><i id="progressBar"></i></div>
      </div>

      <div style="margin-top:12px; display:flex; gap:12px; align-items:center; justify-content:space-between;">
        <div class="features" id="featureList"></div>
        <div style="flex:1"></div>
        <div style="min-width:220px">
          <div class="small-ghost small" id="stats">No output yet</div>
        </div>
      </div>
    </div>

    <!-- RIGHT: sidebar -->
    <div class="card sidebar anim-fade" id="sideCard">
      <div>
        <div class="label">Features by Level</div>
        <div class="preview" id="featPreview">Select a level to see what happens.</div>
      </div>

      <div style="margin-top:10px">
        <div class="label">Output actions</div>
        <div class="actionRow">
          <button class="btn" id="copyBtn">Copy</button>
          <button class="btn" id="downloadBtn">Download</button>
          <button class="btn" id="clearOutBtn">Clear Output</button>
          <button class="btn" id="openWindowBtn">Open in New Window</button>
        </div>
      </div>

      <div style="margin-top:12px">
        <div class="label">Output</div>
        <textarea id="outputArea" class="textarea" style="height:220px" placeholder="Obfuscated output will appear here" readonly></textarea>
        <div class="footer">Lines: <span id="outLines">0</span> â€¢ Size: <span id="outSize">0</span> KB</div>
      </div>

      <div style="margin-top:12px">
        <div class="label">Quick tips</div>
        <ul class="small" style="padding-left:16px">
          <li>Use a key for deterministic renames & string xor.</li>
          <li>Luau may restrict loadstring â€” loader tries safe patterns.</li>
          <li>Level 7+ uses wrappers which may make debugging harder.</li>
        </ul>
      </div>
    </div>
  </div>
</div>

<script>
/*
  Luau / Lua Obfuscator â€” Logic
  - pipeline: minify -> safeRename -> encodeStrings -> junk -> flatten -> multi-wrap -> antiTamper
  - safeRename avoids Lua keywords and common globals
  - string encoding produces runtime decoder inserted at top
  - loader tries loadstring -> load -> load with pcall depending target
  - operations chunked to avoid UI freeze
*/

const $ = id => document.getElementById(id);

// --- UI setup ---
const levelSelect = $("levelSelect"), featPreview = $("featPreview"), featureList = $("featureList");
const progressBar = $("progressBar"), statsBox = $("stats");
const inputArea = $("inputArea"), outputArea = $("outputArea");
const outLines = $("outLines"), outSize = $("outSize");
const targetSelect = $("targetSelect");
const antiTamperEl = $("antiTamper"), multiWrapEl = $("multiWrap");

const levelFeatures = [
  "Minify whitespace & comments",
  "Safe variable rename (skip keywords / globals)",
  "Encode strings (xor -> base64) & add runtime decoder",
  "Inject safe junk definitions",
  "Flatten simple control flow (wrapper function & index runner)",
  "Extra junk & opaque locals",
  "Multi-wrap via load-string layers",
  "Anti-tamper runtime guard",
  "Heavy wrapping (more layers + disguised loader)",
  "Mix: extra junk + flatten + heavy wrap"
];

for (let i=1;i<=10;i++){
  const op = document.createElement("option");
  op.value = i; op.text = `Level ${i}`;
  levelSelect.appendChild(op);
}
levelSelect.value = 6; renderFeatures(6);

// render feature list (sidebar small)
function renderFeatures(lvl){
  featureList.innerHTML = "";
  featPreview.innerText = "";
  for (let i=0;i<levelFeatures.length;i++){
    const div = document.createElement("div");
    div.className = "feature " + (i < lvl ? "ok" : "no");
    div.innerHTML = `<div style="width:8px;height:8px;border-radius:99px;background:${i<lvl?'var(--ok)':'var(--danger)'}"></div>
                     <div style="font-weight:700">${levelFeatures[i]}</div>`;
    featureList.appendChild(div);
  }
  featPreview.innerText = `Level ${lvl} includes:\n` + levelFeatures.slice(0,lvl).map((v,i)=>`â€¢ ${v}`).join("\n");
  // progress UI
  progressBar.style.width = (lvl*10) + "%";
}
levelSelect.addEventListener("change", ()=>renderFeatures(parseInt(levelSelect.value)));

// --- Helpers: safe keyword lists ---
const LUA_KEYWORDS = new Set([
  "and","break","do","else","elseif","end","false","for","function","goto","if","in","local","nil","not","or",
  "repeat","return","then","true","until","while"
]);
const COMMON_GLOBALS = new Set([
  "_G","_ENV","print","warn","require","pairs","ipairs","next","type","tonumber","tostring","math","string",
  "table","coroutine","os","package","io","loadstring","load","pcall","xpcall","spawn","task","workspace","game",
  "workspace","script","tick","delay"
]);

// safe identifier matcher: skip keywords and numeric-leading etc.
function extractIdentifiers(code){
  // crude: match words that look like identifiers
  const ids = new Set();
  const re = /\b([A-Za-z_][A-Za-z0-9_]*)\b/g;
  let m;
  while((m = re.exec(code)) !== null){
    const id = m[1];
    if (LUA_KEYWORDS.has(id)) continue;
    if (COMMON_GLOBALS.has(id)) continue;
    ids.add(id);
  }
  return Array.from(ids);
}

// generate deterministic name from key + original
function nameFromKey(orig, key, idx){
  // produce short safe names: _a1b2 style
  // if key provided, include hashed part
  const base = (key||"").toString();
  let h = 0;
  for (let i=0;i<base.length;i++) h = ((h<<5)-h)+base.charCodeAt(i);
  h = Math.abs(h||0);
  const rand = Math.abs(hashString(orig + ":" + idx + ":" + h)).toString(36).substr(0,6);
  return "_" + rand;
}
function hashString(s){
  let h=2166136261;
  for (let i=0;i<s.length;i++){
    h ^= s.charCodeAt(i);
    h += (h<<1) + (h<<4) + (h<<7) + (h<<8) + (h<<24);
  }
  return h >>> 0;
}

// Minify: remove comments (not long bracket ones) and trim extra whitespace
function minifyLua(src){
  // preserve long bracket multiline strings: replace them temporarily
  const longBrackets = [];
  src = src.replace(/(\[=*\[)([\s\S]*?)(\]=*\])/g, function(m, p1, body, p3){
    const key = "___LONG_BRACKET_" + longBrackets.length + "___";
    longBrackets.push(p1 + body + p3);
    return `"${key}"`; // placeholder in double quotes to avoid further processing
  });

  // remove single-line comments -- but keep those inside strings (we removed long ones)
  // first remove --[[...]] multiline comments safely
  src = src.replace(/--\[\[([\s\S]*?)\]\]/g, ""); // simple
  // remove '--' comments
  src = src.replace(/--.*$/gm, "");
  // remove excess whitespace
  src = src.replace(/\r\n/g, "\n").replace(/[ \t]+\n/g, "\n").replace(/\n{2,}/g, "\n");
  // trim lines
  src = src.split("\n").map(l => l.trim()).join("\n");
  // restore long brackets
  for (let i=0;i<longBrackets.length;i++){
    src = src.replace(`"___LONG_BRACKET_${i}___"`, longBrackets[i]);
  }
  return src.trim();
}

// Safe rename: replace identifiers but only whole words not after '.' (table access) and not function definitions' keywords
function safeRename(code, key){
  const ids = extractIdentifiers(code);
  // sort by length desc to avoid partial replace
  ids.sort((a,b)=>b.length - a.length);
  const mapping = {};
  for (let i=0;i<ids.length;i++){
    const orig = ids[i];
    mapping[orig] = nameFromKey(orig, key, i);
  }
  // replace using regex with boundary, avoid patterns like .orig or :orig (table access)
  // we'll perform multiple passes with negative lookbehind to skip '.' and ':'
  // Note: JS lookbehind is supported in modern browsers; fallback: handle via tokenization
  for (const orig of Object.keys(mapping)){
    const repl = mapping[orig];
    // regex - replace identifiers that are not preceded by . or : or [ or letters (to reduce overreplace)
    // We'll use function to check surrounding chars
    code = code.replace(new RegExp("\\b" + escapeRegExp(orig) + "\\b", "g"), function(m, offset){
      const before = code[offset - 1] || "";
      if (before === "." || before === ":" || before === "[" ) return m; // table access or indexing
      // avoid replacing 'function name' when followed by '('? Actually still safe.
      if (LUA_KEYWORDS.has(m)) return m;
      return repl;
    });
  }
  return code;
}
function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

// Encode strings: find "..." '...' and long bracket strings and encode their content
function encodeStrings(code, key){
  // collect long bracket strings and single/double quoted strings
  const parts = [];
  let out = "";
  let i = 0;
  const push = (s) => { parts.push(s); return "__ENCODED_STR_" + (parts.length-1) + "__"; };

  // parse basic tokenizer simplified
  while (i < code.length){
    const ch = code[i];
    if (ch === '"' || ch === "'"){
      const quote = ch;
      let j = i+1;
      let esc = false;
      let buf = "";
      while (j < code.length){
        const c = code[j];
        if (!esc && c === quote) { j++; break; }
        if (!esc && c === "\\"){ esc = true; buf += c; j++; continue; }
        buf += c; esc = false; j++;
      }
      out += push(quote + buf + quote);
      i = j;
      continue;
    }
    // long bracket
    if (ch === "[" && (code[i+1] === "[" || code[i+1] === "=")){
      // find closing
      const m = code.slice(i).match(/^(\[=*\[)/);
      if (m){
        const open = m[1];
        const close = open.replace("[","]");
        const idx = code.indexOf(close, i+open.length);
        let content, j;
        if (idx >= 0){
          content = code.slice(i, idx + close.length);
          j = idx + close.length;
        } else {
          // unmatched: consume rest
          content = code.slice(i);
          j = code.length;
        }
        out += push(content);
        i = j;
        continue;
      }
    }
    out += ch; i++;
  }

  // encode each part
  const encParts = parts.map(s => {
    // if long bracket or quoted
    if (s[0] === "[" ){
      // remove outer brackets and content
      // encode inner bytes base64 after XOR with key
      const inner = s.replace(/^\[=*\[/,"").replace(/\]=*\]$/,"");
      return encodeAndWrap(inner, key, true);
    } else {
      // quoted string retain quotes
      const q = s[0];
      const inner = s.slice(1,-1);
      return encodeAndWrap(inner, key, false, q);
    }
  });

  // reassemble replacing placeholders
  let final = out.replace(/__ENCODED_STR_(\d+)__/g, function(_, n){
    return encParts[Number(n)];
  });
  return final;
}

// encode string using XOR with key => base64, wrap with decoder call at runtime
function encodeAndWrap(s, key, isLongBracket=false, quoteChar='"'){
  // produce base64 of xor bytes
  const xorKey = key || String.fromCharCode(42);
  let bytes = [];
  for (let i=0;i<s.length;i++){
    const code = s.charCodeAt(i) ^ xorKey.charCodeAt(i % xorKey.length);
    bytes.push(String.fromCharCode(code));
  }
  // base64
  const b64 = btoa(bytes.join(''));
  // wrapper: place a placeholder call to __decode("b64", key, long)
  if (isLongBracket){
    // we reconstruct via long bracket: [[...]] output from decoder will be inserted as string literal using long bracket decode wrapper
    return `__DECODE_LONG("${b64}")`;
  } else {
    // use string literal produced by decoder string: __DECODE("b64")
    return `__DECODE("${b64}")`;
  }
}

// generate runtime decoder for target (Luau/Lua51) â€” returns prefix string to prepend
function runtimeDecoderSnippet(key, target){
  // We'll inject two helper functions: __DECODE(b64) and __DECODE_LONG(b64) and a base64 decoder
  // For Luau, certain functions may be absent; we try to use 'game' independent code.
  // Use a compact decoder in pure Lua that works in 5.1 and Luau
  const xorKey = key ? key : "";
  const decoder = `
-- Runtime string decoder (injected by obfuscator)
local __OBF_XOR_KEY = ${JSON.stringify(xorKey)}
local function __b64dec(s)
  local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  s = string.gsub(s, '[^'..b..'=]', '')
  local t={}
  local p=1
  for i=1,#s,4 do
    local c1 = string.find(b, s:sub(i,i)) or 0
    local c2 = string.find(b, s:sub(i+1,i+1)) or 0
    local c3 = string.find(b, s:sub(i+2,i+2)) or 0
    local c4 = string.find(b, s:sub(i+3,i+3)) or 0
    local n = c1*262144 + c2*4096 + c3*64 + c4
    local a = math.floor(n / 65536) % 256
    local b_ = math.floor(n / 256) % 256
    local c_ = n % 256
    if s:sub(i+2,i+2) == '=' then
      t[p] = string.char(a); p=p+1
    elseif s:sub(i+3,i+3) == '=' then
      t[p] = string.char(a); t[p+1] = string.char(b_); p=p+2
    else
      t[p] = string.char(a); t[p+1] = string.char(b_); t[p+2] = string.char(c_); p=p+3
    end
  end
  return table.concat(t)
end

local function __xorstr(s)
  if __OBF_XOR_KEY == '' then return s end
  local out = {}
  for i=1,#s do
    local a = string.byte(s, i)
    local k = string.byte(__OBF_XOR_KEY, ((i-1) % #__OBF_XOR_KEY)+1)
    out[i] = string.char(bit32 and bit32.bxor and bit32.bxor(a,k) or (a ~ k))
  end
  return table.concat(out)
end

function __DECODE(b64)
  local dec = __b64dec(b64)
  local res = __xorstr(dec)
  return res
end

function __DECODE_LONG(b64)
  return __DECODE(b64)
end
`;
  return decoder;
}

// safe junk generator
function injectJunk(n=1){
  // produce safe local junk variables or no-op functions
  let out = "";
  for (let i=0;i<n;i++){
    const id = "_j" + Math.random().toString(36).substr(2,6);
    out += stringLine(`local ${id} = function(...) return (...) end`);
  }
  return out;
}
function stringLine(s){ return s + "\n"; }

// flatten: wrap code into numbered function table runner
function flattenCode(code){
  // split into smaller chunks by statements (split by ';' or newline). Keep it simple.
  const lines = code.split("\n").filter(l=>l.trim().length>0);
  const parts = [];
  const chunkSize = Math.max(1, Math.ceil(lines.length / Math.min(8, Math.max(2, Math.floor(lines.length/6)))));
  for (let i=0;i<lines.length;i+=chunkSize){
    parts.push(lines.slice(i, i+chunkSize).join("\n"));
  }
  // build runner
  let out = "do\n local __parts = {}\n";
  for (let i=0;i<parts.length;i++){
    const p = parts[i].replace(/(^|\n)/g, "$1  ");
    out += ` __parts[${i+1}] = function()\n${p}\n end\n`;
  }
  out += " local __idx = 1\n while __idx <= #" + "__parts do\n   local ok = pcall(__parts[__idx])\n   if not ok then break end\n   __idx = __idx + 1\n end\nend\n";
  return out;
}

// multiWrap: wrap `code` in loadstring layers (or load) depending on target; produce code that decodes via loadstring loader
function multiWrap(code, layers=1, target="lua51"){
  // base: we will create code = 'local s = [[BASE64]]; local f = loadstring or load; f(s)()'
  let current = code;
  for (let i=0;i<layers;i++){
    const b64 = btoa(current);
    // use long bracket string and load via loadstring or load
    const loadFn = (target === "lua51") ? "loadstring" : "load";
    // create wrapper that supports both: try loadstring then load
    const wrapper = `
do
  local __s = "${b64}"
  local __ok, __fn = pcall(function()
    local _loader = rawget(_G or {}, "loadstring") or load
    if type(_loader) ~= "function" then _loader = load end
    return _loader(__s)
  end)
  if __ok and type(__fn) == "function" then
    __fn()
  end
end
`;
    current = wrapper;
  }
  return current;
}

// antiTamper: inject a runtime guard that sets a global flag and errors if modified
function antiTamperWrap(code){
  const guard = `
do
  local __guard = {}
  local __k = "__OBF_TAMPER_GUARD_" .. tostring(math.random(1000,9999))
  if rawget(_G or {}, "__OBF_GUARD") then error("Tamper detected") end
  rawset(_G or {}, "__OBF_GUARD", __k)
end
`;
  return guard + "\n" + code;
}

// file utilities
function downloadText(filename, text){
  const blob = new Blob([text], {type: "text/plain"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(a.href);
}

// chunking for UI responsiveness
function chunkedProcess(tasks, onProgress, onDone){
  let i=0;
  function step(){
    const start = performance.now();
    while (i<tasks.length && (performance.now() - start < 15)){
      tasks[i++]();
    }
    if (onProgress) onProgress(i/tasks.length);
    if (i < tasks.length) setTimeout(step, 8);
    else onDone && onDone();
  }
  step();
}

// --- Core obfuscate pipeline ---
function obfuscatePipeline(src, options, cbProgress){
  // options: level, key, target, antiTamper, multiWrap
  let steps = [];
  let current = src;
  const lvl = options.level || 1;

  // Step 1: minify always at level >=1
  if (lvl >= 1) steps.push(()=>{ current = minifyLua(current); cbProgress && cbProgress(0.05); });

  // Step 2: safe rename
  if (lvl >= 2) steps.push(()=>{ current = safeRename(current, options.key||""); cbProgress && cbProgress(0.15); });

  // Step 3: encode strings & inject runtime decoder placeholder
  if (lvl >= 3) steps.push(()=>{ current = encodeStrings(current, options.key||""); cbProgress && cbProgress(0.30); });

  // Step 4: junk injection
  if (lvl >= 4) steps.push(()=>{ current = injectJunk( Math.min(4, Math.max(1, Math.floor(lvl/2))) ) + "\n" + current; cbProgress && cbProgress(0.40); });

  // Step 5: flatten
  if (lvl >= 5) steps.push(()=>{ current = flattenCode(current); cbProgress && cbProgress(0.55); });

  // Step 6: extra junk
  if (lvl >= 6) steps.push(()=>{ current = injectJunk(3) + "\n" + current; cbProgress && cbProgress(0.65); });

  // Step 7: multi-wrap
  if (lvl >= 7 && options.multiWrap) steps.push(()=>{ current = multiWrap(current, 1 + Math.floor(lvl/7), options.target); cbProgress && cbProgress(0.78); });

  // Step 8: anti-tamper
  if (lvl >= 8 && options.antiTamper) steps.push(()=>{ current = antiTamperWrap(current); cbProgress && cbProgress(0.85); });

  // Step 9: heavy wrap
  if (lvl >= 9 && options.multiWrap) steps.push(()=>{ current = multiWrap(current, 2 + Math.floor((lvl-8)/2), options.target); cbProgress && cbProgress(0.92); });

  // Step 10: final mix
  if (lvl >= 10) steps.push(()=>{ current = injectJunk(2) + "\n" + flattenCode(current); cbProgress && cbProgress(0.98); });

  // final step: prepend runtime decoder if strings encoded
  steps.push(()=>{ current = runtimeDecoderSnippet(options.key||"", options.target) + "\n" + current; cbProgress && cbProgress(1.0); });

  // chunked process
  return new Promise((resolve)=>{
    chunkedProcess(steps, (p)=>{/*progress*/}, ()=>resolve(current));
  });
}

// --- UI events ---
$("uploadBtn").addEventListener("click", ()=>$("fileInput").click());
$("fileInput").addEventListener("change", e=>{
  const f = e.target.files[0];
  if (!f) return;
  const reader = new FileReader();
  reader.onload = ()=>{ inputArea.value = reader.result; };
  reader.readAsText(f);
});

$("clearIn").addEventListener("click", ()=> inputArea.value = "");

$("sampleBtn").addEventListener("click", ()=>{
  const sample = `-- Sample Luau / Lua 5.1 code
local function greet(name)
  print("Hello, "..name.."!")
end

local t = {a=1, b=2}
for k,v in pairs(t) do
  print(k,v)
end

greet("world")`;
  inputArea.value = sample;
});

// run
$("runBtn").addEventListener("click", async ()=>{
  const src = inputArea.value || "";
  if (!src.trim()){ alert("Paste code first!"); return; }
  const lvl = parseInt(levelSelect.value);
  const key = $("keyInput").value || "";
  const target = targetSelect.value;
  const antiTamper = antiTamperEl.checked;
  const multiWrap = multiWrapEl.checked;

  // reset UI
  outputArea.value = "";
  progressBar.style.width = "6%";
  statsBox.innerText = "Working...";

  // show incremental progress
  const progressFn = (p) => { progressBar.style.width = (6 + Math.floor(p*92)) + "%"; };

  const start = performance.now();
  const out = await obfuscatePipeline(src, {level:lvl, key, target, antiTamper, multiWrap}, progressFn);

  // update UI
  outputArea.value = out;
  outLines.innerText = out.split("\n").length;
  outSize.innerText = (out.length/1024).toFixed(2);
  statsBox.innerText = `Done in ${Math.round(performance.now()-start)} ms â€¢ Level ${lvl} â€¢ Target ${target}`;
  progressBar.style.width = "100%";
});

// preview small (shows top 200 chars)
$("previewBtn").addEventListener("click", ()=>{
  const src = inputArea.value || "";
  if (!src.trim()){ alert("Paste code first!"); return; }
  const lvl = parseInt(levelSelect.value);
  const key = $("keyInput").value || "";
  const target = targetSelect.value;
  obfuscatePipeline(src, {level:lvl, key, target, antiTamper:antiTamperEl.checked, multiWrap:multiWrapEl.checked}, ()=>{}).then(out=>{
    alert("Preview (first 600 chars):\n\n" + out.slice(0,600));
  });
});

// outputs
$("copyBtn").addEventListener("click", async ()=>{
  const v = outputArea.value;
  if (!v){ alert("No output"); return; }
  try{
    await navigator.clipboard.writeText(v);
    alert("Copied to clipboard!");
  }catch(e){ alert("Clipboard failed. Try download."); }
});
$("downloadBtn").addEventListener("click", ()=>{
  const v = outputArea.value;
  if (!v){ alert("No output"); return; }
  const filename = `luobf-${Date.now()}.lua`;
  downloadText(filename, v);
});
$("clearOutBtn").addEventListener("click", ()=>{
  outputArea.value = ""; outLines.innerText = "0"; outSize.innerText = "0"; statsBox.innerText = "No output yet";
});
$("openWindowBtn").addEventListener("click", ()=>{
  const v = outputArea.value;
  if (!v){ alert("No output"); return; }
  const w = window.open("", "_blank");
  w.document.write("<pre style='white-space:pre-wrap;font-family:monospace;padding:12px;background:#0b1220;color:#dbe8ff'>" + escapeHtml(v) + "</pre>");
  w.document.title = "Obfuscated Output";
});

// Help
$("helpBtn").addEventListener("click", ()=> {
  alert("Quick help:\n\nâ€¢ Paste Luau or Lua 5.1 code on the left.\nâ€¢ Choose target (Luau often disables loadstring; loader tries safe options).\nâ€¢ Level increases transformations (minify â†’ rename â†’ encode â†’ wrappers).\nâ€¢ Use a key for deterministic renames & XOR string encoding.\nâ€¢ Preview to inspect small output before using on real projects.\n\nNote: This obfuscator uses heuristic regex transforms; for production-grade obfuscation consider AST-based tooling.");
});

// small utilities
function escapeHtml(s){ return s.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"); }
function btoa(str){
  try { return window.btoa(unescape(encodeURIComponent(str))); }
  catch(e){ // fallback for arbitrary binary
    let bin = "";
    for (let i=0;i<str.length;i++) bin += String.fromCharCode(str.charCodeAt(i) & 0xff);
    return window.btoa(bin);
  }
}

function atobSafe(s){
  try { return decodeURIComponent(escape(window.atob(s))); }
  catch(e){ return window.atob(s); }
}

// small animation: reveal anim
setTimeout(()=>{ document.querySelectorAll(".anim-fade").forEach(el=>el.classList.add("visible")); }, 60);

</script>
</body>
</html>
