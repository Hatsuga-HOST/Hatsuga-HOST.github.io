<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lua Obfuscator – Multi-Layer (Client-Side)</title>
  <meta name="description" content="Client-side multi-layer Lua obfuscator — identifier renaming, string encryption, control-flow flattening, junk insertion & loader packing."/>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root{--bg:#0b0f14;--panel:#121823;--muted:#9aa4b2;--fg:#e7edf3;--brand:#7c5cff;--brand2:#34d399;--danger:#ef4444;--ok:#10b981}
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:radial-gradient(1200px 800px at 80% -10%,#1a2231 0%,transparent 60%),linear-gradient(180deg,#0a0e14,#0b0f14);color:var(--fg)}
    .wrap{max-width:1100px;margin:32px auto;padding:0 16px}
    .title{display:flex;align-items:center;gap:12px}
    .title h1{font-size:clamp(20px,3.2vw,32px);margin:0;font-weight:700}
    .badge{font-size:12px;background:linear-gradient(90deg,var(--brand),#4f46e5);padding:4px 8px;border-radius:999px}
    .grid{display:grid;grid-template-columns:1fr;gap:16px;margin-top:16px}
    @media(min-width:960px){.grid{grid-template-columns:1fr 1fr}}
    .card{background:linear-gradient(180deg,#0e1521, #0c1220);border:1px solid rgba(124,92,255,.25);border-radius:16px;box-shadow:0 10px 40px rgba(0,0,0,.35);overflow:hidden}
    .card h3{margin:0;padding:14px 16px;border-bottom:1px solid rgba(124,92,255,.18);background:linear-gradient(180deg,rgba(124,92,255,.12),transparent)}
    textarea{width:100%;height:360px;resize:vertical;background:#0a0f18;color:var(--fg);border:1px solid #1f2a3b;border-radius:12px;padding:12px;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:13px;line-height:1.5}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    .row > *{margin-top:8px}
    .btn{appearance:none;border:1px solid #273347;background:linear-gradient(180deg,#152033,#111827);color:var(--fg);padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:600}
    .btn:hover{border-color:#334155;transform:translateY(-1px)}
    .btn.primary{border-color:transparent;background:linear-gradient(90deg,var(--brand),#4f46e5);box-shadow:0 8px 24px rgba(124,92,255,.32)}
    .btn.good{background:linear-gradient(90deg,var(--brand2),#10b981);border-color:transparent}
    .btn.danger{background:linear-gradient(90deg,#f43f5e,#ef4444);border-color:transparent}
    .switch{display:inline-flex;align-items:center;gap:6px;font-size:13px;color:var(--muted)}
    input[type="checkbox"]{width:18px;height:18px}
    input[type="file"]{display:none}
    .pill{display:inline-flex;align-items:center;gap:8px;border:1px dashed #273347;padding:8px 10px;border-radius:12px;color:var(--muted)}
    .muted{color:var(--muted)}
    .label{font-size:12px;color:var(--muted);margin-left:4px}
    input[type="password"], input[type="text"]{background:#0a0f18;color:var(--fg);border:1px solid #1f2a3b;border-radius:10px;padding:10px 12px}
    .footer{margin:20px 0;color:var(--muted);font-size:12px}
    .kudos{opacity:.9}
    .small{font-size:12px;color:var(--muted)}
    .options{display:flex;flex-direction:column;gap:8px}
    .badge-opt{font-size:11px;padding:6px 8px;border-radius:10px;background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.02)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="title">
      <svg width="34" height="34" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 2l3 6 6 .9-4.5 4.3 1.1 6.2L12 16l-5.6 3.4 1.1-6.2L3 8.9 9 8l3-6z" stroke="#7c5cff" stroke-width="1.2"/></svg>
      <h1>Lua Obfuscator – Multi-Layer (Client-Side)</h1>
      <span class="badge">no server • multi-pass</span>
    </div>
    <div class="grid">
      <div class="card">
        <h3>1) Source Code</h3>
        <div style="padding:14px 16px;">
          <textarea id="input" placeholder="-- Paste your Lua here"></textarea>
          <div class="row">
            <label class="switch"><input id="minify" type="checkbox" checked>Minify</label>
            <label class="switch"><input id="renameIds" type="checkbox" checked>Rename identifiers</label>
            <label class="switch"><input id="cfFlatten" type="checkbox" checked>Control-flow flatten</label>
            <label class="switch"><input id="junk" type="checkbox" checked>Insert junk code</label>
          </div>

          <div style="margin-top:10px" class="row">
            <label class="switch"><input id="stringEnc" type="checkbox" checked>String encrypt (XOR)</label>
            <label class="switch"><input id="layered" type="checkbox" checked>Multi-layer pack (passes)</label>
            <label class="switch"><input id="integrity" type="checkbox">Runtime integrity check</label>
          </div>

          <div style="margin-top:10px" class="row">
            <span class="pill">Key: <input id="key" type="password" placeholder="optional secret" style="min-width:160px"></span>
            <span class="pill">Watermark: <input id="watermark" type="text" placeholder="@ziaanteam" style="min-width:140px"></span>
            <span class="pill">Passes: <input id="passes" type="number" value="2" min="1" max="6" style="width:64px"></span>
          </div>

          <div style="margin-top:12px" class="row">
            <label class="btn">
              <input id="file" type="file" accept=".lua,.txt" />Upload .lua
            </label>
            <button class="btn" id="example">Load Example</button>
            <button class="btn danger" id="clear">Clear</button>
          </div>
        </div>
      </div>

      <div class="card">
        <h3>2) Obfuscate</h3>
        <div style="padding:14px 16px;display:flex;flex-direction:column;gap:12px">
          <div class="row">
            <button class="btn primary" id="run">Obfuscate Now</button>
            <button class="btn" id="copy">Copy Output</button>
            <button class="btn good" id="download">Download .lua</button>
          </div>
          <textarea id="output" placeholder="-- Obfuscated output will appear here" readonly></textarea>
          <div class="footer">
            <div><strong>Note:</strong> Ini adalah obfuscator **client-side** yang menambahkan banyak lapis pengacakan. Tidak ada yang 100% aman — gabungkan dengan mekanisme server/lisensi bila perlu.</div>
          </div>
        </div>
      </div>
    </div>

    <p class="footer small">How to deploy: place <code>index.html</code> in GitHub Pages. Made by Ziaan & Ilham — gunakan dengan bijak.</p>
  </div>

<script>
/* ============================
   Multi-Layer Lua Obfuscator
   - Techniques included:
     * Minify (light)
     * Identifier renaming (regex-based, best-effort)
     * String encryption (XOR chunks + base64)
     * Control-flow flattening (dispatcher)
     * Junk code insertion
     * Multi-pass packing layers + loader
     * Optional runtime integrity (adler32)
   - Warning: heuristics — not a full AST parser; edge cases possible (long bracket strings, weird metatables)
   ============================ */

const $ = id => document.getElementById(id);
const encoder = new TextEncoder(), decoder = new TextDecoder();

/* ----- Utilities ----- */
function randHexBytes(len){
  const arr = new Uint8Array(len);
  crypto.getRandomValues(arr);
  let s = '';
  for(let b of arr){ s += ('0'+b.toString(16)).slice(-2); }
  return s;
}
function randIdent(len=8){
  const CH='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
  let s='';
  for(let i=0;i<len;i++) s += CH[Math.floor(Math.random()*CH.length)];
  // add numeric tail sometimes
  return s + Math.floor(Math.random()*9999);
}
function b64encode(bytes){
  let bin=''; for(let i=0;i<bytes.length;i++) bin += String.fromCharCode(bytes[i]);
  return btoa(bin);
}
function b64decode(str){
  const bin = atob(str);
  const out = new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) out[i] = bin.charCodeAt(i);
  return out;
}
function xorBytes(data, keyBytes){
  if(!keyBytes || keyBytes.length===0) return data;
  const out = new Uint8Array(data.length);
  for(let i=0;i<data.length;i++) out[i] = data[i] ^ keyBytes[i % keyBytes.length];
  return out;
}
function adler32(str){
  // simple adler32 for integrity
  let a=1, b=0;
  for(let i=0;i<str.length;i++){
    a = (a + str.charCodeAt(i)) % 65521;
    b = (b + a) % 65521;
  }
  return ((b<<16) | a) >>> 0;
}

/* ----- Minify (improved) ----- */
function minifyLua(src){
  // Keep long [[ ... ]] blocks and strings intact, remove comments & extra whitespace outside strings
  // This is still heuristic-based.
  // Step 1: extract long brackets and strings into placeholders
  const placeholders = [];
  let i=0, n=src.length, out='';
  while(i<n){
    if(src[i]=='\'' || src[i]=='"'){
      const q = src[i], start=i;
      i++;
      while(i<n){
        if(src[i]==='\\') { i+=2; continue; }
        if(src[i]===q){ i++; break; }
        i++;
      }
      placeholders.push(src.slice(start,i));
      out += `\u0000S${placeholders.length-1}\u0000`;
      continue;
    }
    if(src[i]=='['){
      // check for long bracket start [=*[ 
      let j=i+1, eq=0;
      while(j<n && src[j]=='='){ eq++; j++; }
      if(j<n && src[j]=='['){
        // find matching
        const openEq = eq;
        let k=j+1;
        while(k<n){
          if(src[k]==']'){
            let jj=k+1, eq2=0;
            while(jj<n && src[jj]=='='){ eq2++; jj++; }
            if(jj<n && src[jj]==']' && eq2==openEq){
              // close found
              k = jj+1;
              break;
            } else k++;
          } else k++;
        }
        const chunk = src.slice(i,k);
        placeholders.push(chunk);
        out += `\u0000L${placeholders.length-1}\u0000`;
        i = k;
        continue;
      }
    }
    // remove line comments starting with --
    if(src[i]=='-' && src[i+1]=='-'){
      // if it's a long bracket comment, it would have been captured already
      while(i<n && src[i] !== '\n') i++;
      if(i<n) { out += '\n'; i++; }
      continue;
    }
    out += src[i++];
  }

  // collapse whitespace outside placeholders
  out = out.replace(/[ \t\f\v\r]+/g,' ');
  out = out.replace(/\n\s*\n+/g,'\n'); // multiple blank lines -> one
  out = out.replace(/[ \t]*\n[ \t]*/g,'\n'); // trim spaces around newlines
  out = out.replace(/ +/g, ' ');

  // restore placeholders
  out = out.replace(/\u0000S(\d+)\u0000/g, (m,g)=>placeholders[+g]);
  out = out.replace(/\u0000L(\d+)\u0000/g, (m,g)=>placeholders[+g]);
  return out.trim();
}

/* ----- Identifier Renamer (regex heuristic) ----- */
function renameIdentifiers(src){
  // Attempt: find local/function/for variable names and global assignments. This is heuristic.
  // Build symbol table from patterns: local <names>, function <name>(...), for <name>=, for <k>,<v> in pairs(...) etc.
  const symbols = new Set();
  // capture local declarations: local a, b = ...
  const localRegex = /(?:^|[\n;])\s*local\s+([A-Za-z_][A-Za-z0-9_]*(?:\s*,\s*[A-Za-z_][A-Za-z0-9_]*)*)/g;
  let m;
  while((m = localRegex.exec(src)) !== null){
    m[1].split(/\s*,\s*/).forEach(s=>symbols.add(s));
  }
  // function name: function foo.bar.baz(...) or function foo(...) local ...
  const funcRegex = /(?:^|[\n;])\s*function\s+([A-Za-z_][A-Za-z0-9_\.]*)/g;
  while((m = funcRegex.exec(src)) !== null){
    const name = m[1].split('.').pop();
    if(name) symbols.add(name);
  }
  // assignments like foo = function(...) or foo = 123
  const assignRegex = /(?:^|[\n;])\s*([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(?:function|\{|\d|".*?"|'.*?')/g;
  while((m = assignRegex.exec(src)) !== null){
    symbols.add(m[1]);
  }
  // for var in pairs
  const forRegex = /for\s+([A-Za-z_][A-Za-z0-9_]*)\s*(?:,|\b)/g;
  while((m = forRegex.exec(src)) !== null) symbols.add(m[1]);

  // Build mapping
  const map = {};
  for(let s of symbols){
    if(s.length < 3) continue; // keep short builtins
    map[s] = '_' + randIdent(6);
  }
  if(Object.keys(map).length===0) return src;

  // Replace identifiers carefully: use word boundaries, but avoid replacing inside strings/long brackets
  // Extract strings/longs to placeholders
  const placeholders = [];
  let tmp = '', i=0, n=src.length;
  while(i<n){
    if(src[i]==="'" || src[i]==='"'){
      const q=src[i], start=i; i++;
      while(i<n){
        if(src[i]==='\\'){ i+=2; continue; }
        if(src[i]===q){ i++; break; }
        i++;
      }
      placeholders.push(src.slice(start,i));
      tmp += `\u0000S${placeholders.length-1}\u0000`;
      continue;
    }
    if(src[i]=='['){
      // long bracket detection
      let j=i+1, eq=0;
      while(j<n && src[j]=='='){ eq++; j++; }
      if(j<n && src[j]=='['){
        // find close
        let k=j+1;
        while(k<n){
          if(src[k]==']'){
            let jj=k+1, eq2=0;
            while(jj<n && src[jj]=='='){ eq2++; jj++; }
            if(jj<n && src[jj]==']' && eq2==eq){ k = jj+1; break; } else k++;
          } else k++;
        }
        placeholders.push(src.slice(i,k));
        tmp += `\u0000L${placeholders.length-1}\u0000`;
        i = k;
        continue;
      }
    }
    tmp+=src[i++]
  }

  // perform replacements on tmp
  for(const orig in map){
    const re = new RegExp('\\b' + orig + '\\b', 'g');
    tmp = tmp.replace(re, map[orig]);
  }

  // restore placeholders
  tmp = tmp.replace(/\u0000S(\d+)\u0000/g,(m,g)=>placeholders[+g]);
  tmp = tmp.replace(/\u0000L(\d+)\u0000/g,(m,g)=>placeholders[+g]);

  // Return rewritten code + a header mapping comment (obfuscated)
  // We won't output mapping; mapping lost -> hard to reverse
  return tmp;
}

/* ----- String encryption ----- */
function encryptStrings(src, keyBytes){
  // Find string literals and replace with loader calls:
  // "hello" -> __S("...") with base64 of XORed bytes (split into chunks)
  // We preserve long bracket strings untouched.
  let placeholders = [];
  let i=0, n=src.length, out='';
  while(i<n){
    if(src[i]==="'" || src[i]==='"'){
      const q=src[i], start=i;
      i++;
      let s='';
      while(i<n){
        if(src[i]==='\\'){ s += src[i]+src[i+1]; i+=2; continue; }
        if(src[i]===q){ i++; break; }
        s += src[i++]
      }
      // unescape simple escapes (not full)
      const raw = s.replace(/\\n/g,'\n').replace(/\\t/g,'\t').replace(/\\r/g,'\r').replace(/\\'/g,"'").replace(/\\"/g,'"').replace(/\\\\/g,'\\');
      // encode raw to bytes
      const bytes = encoder.encode(raw);
      const x = xorBytes(bytes, keyBytes);
      const b64 = b64encode(x);
      // split into chunks of random sizes to confuse
      const chunks = [];
      for(let p=0;p<b64.length;){
        const sz = 8 + Math.floor(Math.random()*24);
        chunks.push(b64.slice(p, p+sz));
        p += sz;
      }
      // produce loader call that concatenates chunks then base64-decode and xor
      const chunkLua = chunks.map(c=>`"${c}"`).join(' .. ');
      const replacement = `__S(${chunkLua})`;
      out += replacement;
      continue;
    }
    if(src[i]=='['){
      // long bracket -> copy verbatim (preserve)
      let j=i+1, eq=0;
      while(j<n && src[j]=='='){ eq++; j++; }
      if(j<n && src[j]=='['){
        let k=j+1;
        while(k<n){
          if(src[k]==']'){
            let jj=k+1, eq2=0;
            while(jj<n && src[jj]=='='){ eq2++; jj++; }
            if(jj<n && src[jj]==']' && eq2==eq){ k = jj+1; break; } else k++;
          } else k++;
        }
        out += src.slice(i,k);
        i = k;
        continue;
      }
    }
    out += src[i++];
  }

  // Prepend helper __S function (loader) at top
  const helper = `
-- string loader (auto-inserted)
local function __b64d(s)
  local t='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  local d={} for i=1,#t do d[string.byte(t,i)]=i-1 end
  local out={} local n=1 local val=0 local valb=-8
  for i=1,#s do local c=d[string.byte(s,i)]; if c then val=val*64+c; valb=valb+6; if valb>=0 then out[n]=string.char(math.floor(val/(2^valb))%256); n=n+1; val=val%(2^valb); valb=valb-8 end end end
  return table.concat(out)
end
local function __xor_bytes_str(s,k)
  if not k or #k==0 then return s end
  local out={} local n=1
  for i=1,#s do
    local a=string.byte(s,i)
    local b=string.byte(k, ((i-1)%#k)+1 )
    out[n]=string.char((a ~ b) % 256); n=n+1
  end
  return table.concat(out)
end
local __KEY = "${b64encode(keyBytes)}" -- key stored b64 (decoder will decode)
local function __S(...)
  local concat = table.concat{...}
  local raw = __b64d(concat)
  -- decode key
  local key = __b64d(__KEY)
  return __xor_bytes_str(raw, key)
end
`;
  return helper + "\n" + out;
}

/* ----- Control-flow flattening (simple) ----- */
function flattenControlFlow(src){
  // Very small dispatcher-based flattening:
  // Split top-level statements by newline and build table of functions,
  // then create dispatcher loop that executes functions in permuted order using numeric keys and a state table.
  // NOTE: This is shallow and best applied when code is line-oriented.
  const lines = src.split('\n').map(l=>l.trim()).filter(l=>l.length>0);
  if(lines.length < 3) return src; // not worth flattening
  const funcs = [];
  for(let i=0;i<lines.length;i++){
    // wrap each line into function (avoid 'return' at top)
    const fnName = '_f' + i + '_' + Math.floor(Math.random()*9999);
    funcs.push({name:fnName, body: lines[i]});
  }
  // build table and dispatcher
  let tableLua = "local __T = {}\n";
  for(let i=0;i<funcs.length;i++){
    tableLua += stringTemplate(`__T[${i+1}] = function() ${funcs[i].body} end\n`);
  }
  // make random permutation order and runtime index table
  const order = [];
  for(let i=1;i<=funcs.length;i++) order.push(i);
  // shuffle
  for(let i=order.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); const t=order[i]; order[i]=order[j]; order[j]=t; }
  const orderLua = "local __O = {" + order.join(',') + "}\n";
  const dispatcher = `
local __i = 1
while __i <= #__O do
  local idx = __O[__i]
  local ok, err = pcall(__T[idx])
  if not ok then -- if any error, try to continue
    -- noop or log to prevent easy static analysis
    local _ = err
  end
  __i = __i + 1
end
`;
  return tableLua + "\n" + orderLua + "\n" + dispatcher;
}

/* ----- Junk insertion ----- */
function insertJunk(src, count=6){
  // Insert random harmless functions and tables to confuse static readers
  let junk = '';
  for(let i=0;i<count;i++){
    const name = '_junk' + randIdent(4);
    junk += `local ${name} = function(...) local r = 0 for i=1,#(arg or {}) do r = r + (type(arg[i])=='number' and arg[i] or 0) end return r end\n`;
  }
  // place junk at random position: after header or at top
  return junk + "\n" + src;
}

/* ----- Loader packing: builds final lua that decodes base64 payload and runs it ----- */
function makeLuaLoader(base64Payload, keyB64, watermark, doIntegrity, checksum){
  const wm = watermark ? `\n-- ${watermark}` : '';
  // loader uses built-in decoding and optional xor with key (if provided)
  const keyExpr = keyB64 ? `local __K = (function() local s="${keyB64}"; local t='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; local out=''; out = (function() local b=__b64d(s); return b end)(); return out end)()` : `""`;
  // NOTE: we embed minimal __b64d function
  const loader = `-- Packed by Multi-Layer Client Obfuscator${wm}
local __B = [[${base64Payload}]]
local function __b64d(s)
  local t='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  local d={} for i=1,#t do d[string.byte(t,i)]=i-1 end
  local out={} local n=1 local val=0 local valb=-8
  for i=1,#s do local c=d[string.byte(s,i)]; if c then val=val*64+c; valb=valb+6; if valb>=0 then out[n]=string.char(math.floor(val/(2^valb))%256); n=n+1; val=val%(2^valb); valb=valb-8 end end end
  return table.concat(out)
end
local function __xor_str(s,k)
  if not k or #k==0 then return s end
  local out={} local n=1
  for i=1,#s do
    out[n]=string.char((string.byte(s,i) ~ string.byte(k, ((i-1)%#k)+1)) % 256); n=n+1
  end
  return table.concat(out)
end

local __payload = __b64d(__B)
local __key = ${keyB64 ? `__b64d("${keyB64}")` : `""`}
local __decoded = __xor_str(__payload, __key)

${ doIntegrity ? `-- integrity check
local function adler32(s)
  local a,b=1,0
  for i=1,#s do a=(a+string.byte(s,i))%65521; b=(b+a)%65521 end
  return ((b<<16) | a) & 0xFFFFFFFF
end
if adler32(__decoded) ~= ${checksum} then error("integrity failure") end
` : '' }

local __f, __err = (load or loadstring)(__decoded, nil, 't', _ENV or getfenv())
if not __f then error(__err) end
return __f()
`;
  return loader;
}

/* ----- End-to-end build pipeline ----- */
async function buildOnce(src, options){
  let code = src;
  // 1) minify
  if(options.minify) code = minifyLua(code);

  // 2) rename identifiers
  if(options.renameIds) code = renameIdentifiers(code);

  // 3) insert junk
  if(options.junk) code = insertJunk(code, 4 + Math.floor(Math.random()*6));

  // 4) control flow flatten (optional)
  if(options.cfFlatten) {
    // apply flatten to a chunk: for safety, wrap code into a function body, flatten, then return
    // We'll try to flatten the whole code if length permits
    const flattened = flattenControlFlow(code);
    // only accept if result seems larger than original (indicates we applied)
    if(flattened.length > code.length) code = flattened;
  }

  // 5) string encrypt
  const keyStr = options.key || randHexBytes(8);
  // derive key bytes (sha-like) by using raw chars — for browser, produce bytes from key string
  const keyBytes = encoder.encode(keyStr);
  if(options.stringEnc){
    code = encryptStrings(code, keyBytes);
  }

  // optional integrity checksum
  let checksum = 0;
  if(options.integrity){
    checksum = adler32(code).toString();
  }

  // final pack (base64)
  const bytesFinal = encoder.encode(code);
  const b64 = b64encode(bytesFinal);

  // build loader, embed key base64 if stringEnc used
  const keyB64 = options.stringEnc ? b64encode(keyBytes) : "";
  const loader = makeLuaLoader(b64, keyB64, options.watermark || '', options.integrity, checksum);
  return loader;
}

async function runBuild(){
  let code = $("input").value || "";
  if(!code.trim()){ alert("Silakan paste kode Lua terlebih dahulu."); return; }
  const options = {
    minify: $("minify").checked,
    renameIds: $("renameIds").checked,
    cfFlatten: $("cfFlatten").checked,
    junk: $("junk").checked,
    stringEnc: $("stringEnc").checked,
    layered: $("layered").checked,
    integrity: $("integrity").checked,
    key: $("key").value || "",
    watermark: $("watermark").value || "",
    passes: Math.max(1, Math.min(6, parseInt($("passes").value || "2")))
  };

  // Multi-pass: apply pipeline multiple times. Each pass packs the previous output inside loader -> increases effort but also size.
  let out = code;
  try{
    if(!options.layered || options.passes <= 1){
      out = await buildOnce(out, options);
    } else {
      // run 'passes' times, each pass may use different randomization
      for(let p=0;p<options.passes;p++){
        // for inner passes, we usually want minify+stringEnc+junk+rename
        const passOptions = Object.assign({}, options);
        // slightly vary key per pass if user didn't supply fixed key
        if(!options.key) passOptions.key = randHexBytes(8);
        // on inner passes keep integrity only on outermost if chosen
        passOptions.integrity = (p === options.passes-1) ? options.integrity : false;
        out = await buildOnce(out, passOptions);
      }
    }

    $("output").value = out;
  }catch(err){
    console.error(err);
    alert("Error saat obfuscate: " + (err && err.message ? err.message : String(err)));
  }
}

/* ----- Wire UI ----- */
$("run").addEventListener('click', runBuild);
$("copy").addEventListener('click', async ()=>{
  const v = $("output").value; if(!v){alert('Nothing to copy');return}
  await navigator.clipboard.writeText(v);
  const btn = $("copy"); const old=btn.textContent; btn.textContent='Copied!'; setTimeout(()=>btn.textContent=old,1200);
});
$("download").addEventListener('click', ()=>{
  const v = $("output").value; if(!v){alert('Nothing to download');return}
  const blob = new Blob([v], {type:'text/plain'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'obfuscated.lua'; a.click(); URL.revokeObjectURL(a.href);
});
$("clear").addEventListener('click', ()=>{ $("input").value=''; $("output").value=''; });
$("example").addEventListener('click', ()=>{
  $("input").value = `-- example\nlocal secret = "hello koruptor"\nlocal function greet(name)\n  for i=1,3 do print(secret..' '..name..' #'..i) end\nend\nfor i=1,2 do greet('user'..i) end`;
});
$("file").addEventListener('change', async (e)=>{
  const f = e.target.files[0]; if(!f) return;
  const text = await f.text(); $("input").value = text;
});
</script>
</body>
</html>
